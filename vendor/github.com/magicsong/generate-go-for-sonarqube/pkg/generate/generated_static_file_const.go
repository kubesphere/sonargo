// Code generated by generate-go-for-sonarqub, DON'T mannualy edit it

package generate

const SonarqubeConst = "import (\r\n\t\"net/http\"\r\n\t\"net/url\"\r\n\r\n\t\"github.com/google/go-querystring/query\"\r\n)\r\n\r\nconst (\r\n\tdefaultBaseURL = \"http://sonarqube.kubesphere.com/api/\"\r\n\tuserAgent      = \"devops server\"\r\n)\r\n\r\ntype authType int\r\n\r\nconst (\r\n\tbasicAuth authType = iota\r\n\toAuthToken\r\n\tprivateToken\r\n)\r\n\r\nconst (\r\n\tQualifierSubProject = \"BRC\"\r\n\tQualifierDirectory  = \"DIR\"\r\n\tQualifierFile       = \"FIL\"\r\n\tQualifierProject    = \"TRK\"\r\n\tQualifierTestFile   = \"UTS\"\r\n)\r\nfunc (c *Client) BaseURL() *url.URL {\r\n\tu := *c.baseURL\r\n\treturn &u\r\n}\r\n\r\n// SetBaseURL sets the base URL for API requests to a custom endpoint. urlStr\r\n// should always be specified with a trailing slash.\r\nfunc (c *Client) SetBaseURL(urlStr string) error {\r\n\tif u, err := SetBaseURLUtil(urlStr); err != nil {\r\n\t\treturn err\r\n\t} else {\r\n\t\tc.baseURL = u\r\n\t}\r\n\treturn nil\r\n}\r\n\r\n// NewRequest creates an API request. A relative URL path can be provided in\r\n// urlStr, in which case it is resolved relative to the base URL of the Client.\r\n// Relative URL paths should always be specified without a preceding slash. If\r\n// specified, the value pointed to by body is JSON encoded and included as the\r\n// request body.\r\nfunc (c *Client) NewRequest(method, path string, opt interface{}) (*http.Request, error) {\r\n\tu := *c.baseURL\r\n\t// Set the encoded opaque data\r\n\tu.Opaque = c.baseURL.Path + path\r\n\r\n\tif opt != nil {\r\n\t\tq, err := query.Values(opt)\r\n\t\tif err != nil {\r\n\t\t\treturn nil, err\r\n\t\t}\r\n\t\tu.RawQuery = q.Encode()\r\n\t}\r\n\r\n\treq := &http.Request{\r\n\t\tMethod:     method,\r\n\t\tURL:        &u,\r\n\t\tProto:      \"HTTP/1.1\",\r\n\t\tProtoMajor: 1,\r\n\t\tProtoMinor: 1,\r\n\t\tHeader:     make(http.Header),\r\n\t\tHost:       u.Host,\r\n\t}\r\n\r\n\tif method == \"POST\" || method == \"PUT\" {\r\n\t\t// SonarQube use RawQuery even method is POST\r\n\t\t// bodyBytes, err := json.Marshal(opt)\r\n\t\t// if err != nil {\r\n\t\t// \treturn nil, err\r\n\t\t// }\r\n\t\t// bodyReader := bytes.NewReader(bodyBytes)\r\n\r\n\t\t// u.RawQuery = \"\"\r\n\t\t// req.Body = ioutil.NopCloser(bodyReader)\r\n\t\t// req.ContentLength = int64(bodyReader.Len())\r\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\r\n\t}\r\n\r\n\treq.Header.Set(\"Accept\", \"application/json\")\r\n\r\n\tswitch c.authType {\r\n\tcase basicAuth, oAuthToken:\r\n\t\treq.SetBasicAuth(c.username, c.password)\r\n\tcase privateToken:\r\n\t\treq.SetBasicAuth(c.token, \"\")\r\n\t}\r\n\treq.Header.Set(\"User-Agent\", userAgent)\r\n\treturn req, nil\r\n}\r\n\r\n// Do sends an API request and returns the API response. The API response is\r\n// JSON decoded and stored in the value pointed to by v, or returned as an\r\n// error if an API error has occurred. If v implements the io.Writer\r\n// interface, the raw response body will be written to v, without attempting to\r\n// first decode it.\r\nfunc (c *Client) Do(req *http.Request, v interface{}) (*http.Response,error) {\r\n\treturn Do(c.httpClient, req, v)\r\n}\r\n\r\n//Paging is used in many apis\r\ntype Paging struct {\r\n\tPageIndex int64 `json:\"pageIndex,omitempty\"`\r\n\tPageSize  int64 `json:\"pageSize,omitempty\"`\r\n\tTotal     int64 `json:\"total,omitempty\"`\r\n}"
const WebClientConst = "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/google/go-querystring/query\"\n)\n\n// SetBaseURL sets the base URL for API requests to a custom endpoint. urlStr\n// should always be specified with a trailing slash.\nfunc SetBaseURLUtil(urlStr string) (*url.URL, error) {\n\t// Make sure the given URL end with a slash\n\tif !strings.HasSuffix(urlStr, \"/\") {\n\t\turlStr += \"/\"\n\t}\n\n\tbaseURL, err := url.Parse(urlStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Update the base URL of the client.\n\treturn baseURL, nil\n}\n\n// NewRequest creates an API request. A relative URL path can be provided in\n// urlStr, in which case it is resolved relative to the base URL of the Client.\n// Relative URL paths should always be specified without a preceding slash. If\n// specified, the value pointed to by body is JSON encoded and included as the\n// request body.\nfunc NewRequest(method, path string, baseURL *url.URL, username, password string, opt interface{}) (*http.Request, error) {\n\t// Set the encoded opaque data\n\tu := *baseURL\n\tunescaped, err := url.PathUnescape(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu.RawPath = u.Path + path\n\tu.Path = u.Path + unescaped\n\tif opt != nil {\n\t\tq, err := query.Values(opt)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tu.RawQuery = q.Encode()\n\t}\n\n\treq := &http.Request{\n\t\tMethod: method,\n\t\tURL:    &u,\n\t\tProto:  \"HTTP/1.1\",\n\t\tHeader: make(http.Header),\n\t\tHost:   u.Host,\n\t}\n\n\tif method == \"POST\" || method == \"PUT\" {\n\t\t//SonarQube use RawQuery even method is POST\n\t\tbodyBytes, err := json.Marshal(opt)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tbodyReader := bytes.NewReader(bodyBytes)\n\n\t\tu.RawQuery = \"\"\n\t\treq.Body = ioutil.NopCloser(bodyReader)\n\t\treq.ContentLength = int64(bodyReader.Len())\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t}\n\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.SetBasicAuth(username, password)\n\treturn req, nil\n}\n\n// Do sends an API request and returns the API response. The API response is\n// JSON decoded and stored in the value pointed to by v, or returned as an\n// error if an API error has occurred. If v implements the io.Writer\n// interface, the raw response body will be written to v, without attempting to\n// first decode it.\nfunc Do(c *http.Client, req *http.Request, v interface{}) (*http.Response,error) {\n\tisText := false\n\tif _, ok := v.(*string); ok {\n\t\treq.Header.Set(\"Accept\", \"text/plain\")\n\t\tisText = true\n\t}\n\tresp, err := c.Do(req)\n\tif err != nil {\n\t\treturn nil,err\n\t}\n\tdefer resp.Body.Close()\n\terr = CheckResponse(resp)\n\tif err != nil {\n\t\treturn resp,err\n\t}\n\tif v != nil {\n\t\tif w, ok := v.(io.Writer); ok {\n\t\t\t_, err = io.Copy(w, resp.Body)\n\t\t} else {\n\t\t\tif isText {\n\t\t\t\tbyts, err := ioutil.ReadAll(resp.Body)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn resp,err\n\t\t\t\t}\n\t\t\t\tw := v.(*string)\n\t\t\t\t*w = string(byts)\n\t\t\t} else {\n\t\t\t\terr = json.NewDecoder(resp.Body).Decode(v)\n\t\t\t}\n\t\t}\n\t}\n\treturn resp,err\n}\n\ntype ErrorResponse struct {\n\tBody     []byte\n\tResponse *http.Response\n\tMessage  string\n}\n\nfunc (e *ErrorResponse) Error() string {\n\tpath, _ := url.QueryUnescape(e.Response.Request.URL.Path)\n\tu := fmt.Sprintf(\"%s://%s%s\", e.Response.Request.URL.Scheme, e.Response.Request.URL.Host, path)\n\treturn fmt.Sprintf(\"%s %s: %d %s\", e.Response.Request.Method, u, e.Response.StatusCode, e.Message)\n}\nfunc CheckResponse(r *http.Response) error {\n\tswitch r.StatusCode {\n\tcase 200, 201, 202, 204, 304:\n\t\treturn nil\n\t}\n\n\terrorResponse := &ErrorResponse{Response: r}\n\tdata, err := ioutil.ReadAll(r.Body)\n\tif err == nil && data != nil {\n\t\terrorResponse.Body = data\n\n\t\tvar raw interface{}\n\t\tif err := json.Unmarshal(data, &raw); err != nil {\n\t\t\terrorResponse.Message = string(data)\n\t\t} else {\n\t\t\terrorResponse.Message = parseError(raw)\n\t\t}\n\t}\n\n\treturn errorResponse\n}\nfunc parseError(raw interface{}) string {\n\tswitch raw := raw.(type) {\n\tcase string:\n\t\treturn raw\n\n\tcase []interface{}:\n\t\tvar errs []string\n\t\tfor _, v := range raw {\n\t\t\terrs = append(errs, parseError(v))\n\t\t}\n\t\treturn fmt.Sprintf(\"[%s]\", strings.Join(errs, \", \"))\n\n\tcase map[string]interface{}:\n\t\tvar errs []string\n\t\tfor k, v := range raw {\n\t\t\terrs = append(errs, fmt.Sprintf(\"{%s: %s}\", k, parseError(v)))\n\t\t}\n\t\tsort.Strings(errs)\n\t\treturn strings.Join(errs, \", \")\n\n\tdefault:\n\t\treturn fmt.Sprintf(\"failed to parse unexpected error type: %T\", raw)\n\t}\n}\n"
const TestSuiteConst = "import (\n\t\"testing\"\n\t\"os\"\n\n\t{REPLACE_PACKAGENAME}\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n)\n\nvar client *Client\nvar _ = BeforeSuite(func() {\n\tsonarURL := os.Getenv(\"SONAR_URL\")\n\tif sonarURL == \"\" {\n\t\tFail(\"SONAR_URL should not be empty\")\n\t}\n\tc, err := NewClient(sonarURL+\"/api\", \"admin\", \"admin\")\n\tExpect(err).ShouldNot(HaveOccurred())\n\tclient = c\n})\n\nfunc TestSonar(t *testing.T) {\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"Sonar Suite\")\n}\n\n\n"
